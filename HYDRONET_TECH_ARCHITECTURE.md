# ğŸ—ï¸ HydroNet æŠ€æœ¯æ¶æ„æ–¹æ¡ˆ

**åŸºäºHydroSISäº‘æœåŠ¡æ¶æ„çš„å•†ä¸šåŒ–å®æ–½**

**ç‰ˆæœ¬**: 1.0  
**æ—¥æœŸ**: 2025-10-26  
**ç›®æ ‡**: å¿«é€Ÿç”¨æˆ·å¢é•¿ + ä½æˆæœ¬è¿è¥ + æŠ€æœ¯é¢†å…ˆ

---

## ğŸ“‹ ç›®å½•

1. [æ¶æ„è®¾è®¡ç†å¿µ](#1-æ¶æ„è®¾è®¡ç†å¿µ)
2. [æ–¹æ¡ˆä¸€ï¼šå¤§æ¨¡å‹å…¥å£ç¨‹åºï¼ˆæ ¸å¿ƒï¼‰](#2-æ–¹æ¡ˆä¸€å¤§æ¨¡å‹å…¥å£ç¨‹åºæ ¸å¿ƒ)
3. [ä¸¤é˜¶æ®µæŠ€æœ¯æ¼”è¿›](#3-ä¸¤é˜¶æ®µæŠ€æœ¯æ¼”è¿›)
4. [ç”¨æˆ·å¢é•¿æŠ€æœ¯æ”¯æ’‘](#4-ç”¨æˆ·å¢é•¿æŠ€æœ¯æ”¯æ’‘)
5. [å¿«é€Ÿå®æ–½è·¯çº¿](#5-å¿«é€Ÿå®æ–½è·¯çº¿)

---

## 1. æ¶æ„è®¾è®¡ç†å¿µ

### 1.1 è®¾è®¡åŸåˆ™

åŸºäºHydroSISäº‘æœåŠ¡æ¶æ„æ–¹æ¡ˆï¼Œç»“åˆæˆ‘ä»¬çš„**ç”¨æˆ·å¢é•¿ä¼˜å…ˆ**ç­–ç•¥ï¼š

```
âœ… å¿«é€Ÿå¯åŠ¨ > å®Œç¾æ¶æ„
âœ… ç”¨æˆ·ä½“éªŒ > æŠ€æœ¯å¤æ‚åº¦  
âœ… æˆæœ¬æ§åˆ¶ > åŠŸèƒ½å®Œå¤‡æ€§
âœ… å¢é•¿é»‘å®¢ > ä¼ ç»Ÿè¥é”€
```

### 1.2 æ ¸å¿ƒæ¶æ„ï¼ˆå‚è€ƒHydroSISæ–¹æ¡ˆ1ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ç”¨æˆ·ç»ˆç«¯ï¼ˆWeb/å¾®ä¿¡ï¼‰                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ HTTPS
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         é˜¶æ®µä¸€ï¼šå­¦æ ¡æœåŠ¡å™¨ (è‡ªæœ‰100ä¸‡è®¾å¤‡)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚        å‰ç«¯åº”ç”¨ (React/Vue)                          â”‚   â”‚
â”‚  â”‚   - å¯¹è¯ç•Œé¢  - é¡¹ç›®ç®¡ç†  - ç»“æœå±•ç¤º                  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚     Flaskåº”ç”¨ (app_local.py å¢å¼ºç‰ˆ)                  â”‚   â”‚
â”‚  â”‚   - ç”¨æˆ·è®¤è¯  - ä¼šè¯ç®¡ç†  - ä»»åŠ¡è°ƒåº¦                  â”‚   â”‚
â”‚  â”‚   - å…è´¹ç‰ˆé™åˆ¶  - æ¨èç³»ç»Ÿ  - æ•°æ®åˆ†æ                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚     é€šä¹‰åƒé—® APIï¼ˆé˜¿é‡Œäº‘ï¼‰                            â”‚   â”‚
â”‚  â”‚   - AIå¯¹è¯  - å·¥å…·è°ƒç”¨  - æµå¼å“åº”                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚     MCPæœåŠ¡ç®¡ç†å™¨                                     â”‚   â”‚
â”‚  â”‚   - ä»¿çœŸ  - è¾¨è¯†  - è°ƒåº¦  - æ§åˆ¶  - æµ‹è¯•             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚     æ•°æ®å­˜å‚¨ (PostgreSQL + SQLite)                   â”‚   â”‚
â”‚  â”‚   - ç”¨æˆ·æ•°æ®  - å¯¹è¯å†å²  - é¡¹ç›®æ–‡ä»¶  - ç»Ÿè®¡æ•°æ®      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. æ–¹æ¡ˆä¸€ï¼šå¤§æ¨¡å‹å…¥å£ç¨‹åºï¼ˆæ ¸å¿ƒï¼‰

### 2.1 å‰ç«¯è®¾è®¡ï¼ˆç±»Claudeç•Œé¢ï¼‰

å‚è€ƒHydroSISæ–¹æ¡ˆï¼Œä½†ç®€åŒ–å¯åŠ¨ï¼š

#### æŠ€æœ¯æ ˆé€‰æ‹©

**MVPç‰ˆæœ¬ï¼ˆ1-3ä¸ªæœˆï¼‰**ï¼š
```
å‰ç«¯: ç°æœ‰ HTML + JavaScript + Bootstrap
      â†“ å¿«é€Ÿæ”¹é€ æˆç±»Claudeç•Œé¢
ä¼˜åŠ¿: é›¶å­¦ä¹ æˆæœ¬ï¼Œç«‹å³å¯ç”¨
```

**å¢é•¿ç‰ˆæœ¬ï¼ˆ3-6ä¸ªæœˆï¼‰**ï¼š
```typescript
// å‡çº§åˆ°ç°ä»£æ¡†æ¶
å‰ç«¯: Vue 3 + TypeScript + Element Plus
ç†ç”±: 
  - Vueå­¦ä¹ æ›²çº¿å¹³ç¼“
  - Element Plusä¸­æ–‡æ–‡æ¡£å®Œå–„
  - é€‚åˆå¿«é€Ÿå¼€å‘
  - å›½å†…ç”Ÿæ€å¥½
```

#### å¯¹è¯ç•Œé¢è®¾è®¡

```html
<!-- MVPç‰ˆæœ¬ï¼šæ”¹é€ ç°æœ‰index.html -->
<div class="chat-container">
  <!-- ä¾§è¾¹æ  -->
  <div class="sidebar">
    <button class="new-chat-btn">+ æ–°å¯¹è¯</button>
    <div class="conversation-list">
      <!-- å¯¹è¯å†å²åˆ—è¡¨ -->
    </div>
    <div class="user-info">
      <div class="usage-stats">
        <p>æœ¬æœˆå·²ç”¨: <span id="usage-count">15</span>/100æ¬¡</p>
        <p class="upgrade-tip">
          å‡çº§ä¸“ä¸šç‰ˆè§£é”æ— é™æ¬¡æ•° 
          <a href="/pricing">ç«‹å³å‡çº§</a>
        </p>
      </div>
    </div>
  </div>
  
  <!-- ä¸»å¯¹è¯åŒº -->
  <div class="main-chat">
    <div class="messages" id="message-container">
      <!-- æ¶ˆæ¯åˆ—è¡¨ -->
    </div>
    <div class="input-area">
      <textarea id="user-input" placeholder="é—®æˆ‘ä»»ä½•æ°´ç½‘é—®é¢˜..."></textarea>
      <button id="send-btn">å‘é€</button>
      <button id="upload-btn">ğŸ“ ä¸Šä¼ æ–‡ä»¶</button>
    </div>
  </div>
</div>

<style>
/* Claudeé£æ ¼UI */
.chat-container {
  display: flex;
  height: 100vh;
  background: #fff;
}

.sidebar {
  width: 260px;
  background: #f7f7f8;
  border-right: 1px solid #e5e5e5;
}

.main-chat {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.messages {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

.message {
  margin-bottom: 20px;
  animation: fadeIn 0.3s;
}

.message.user {
  text-align: right;
}

.message.assistant .content {
  background: #f0f0f0;
  padding: 12px 16px;
  border-radius: 12px;
  display: inline-block;
  max-width: 80%;
}

/* å·¥å…·è°ƒç”¨å±•ç¤º */
.tool-call {
  background: #e8f4fd;
  border-left: 3px solid #1890ff;
  padding: 10px;
  margin: 10px 0;
  border-radius: 4px;
}

.tool-call-status {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 12px;
}

.tool-call-status.running {
  background: #ffe58f;
  color: #ad6800;
}

.tool-call-status.completed {
  background: #b7eb8f;
  color: #52c41a;
}
</style>

<script>
// æ ¸å¿ƒJavaScript
class ChatInterface {
  constructor() {
    this.ws = null;
    this.conversationId = null;
    this.init();
  }
  
  init() {
    // å»ºç«‹WebSocketè¿æ¥ï¼ˆæµå¼å“åº”ï¼‰
    this.connectWebSocket();
    
    // ç»‘å®šäº‹ä»¶
    document.getElementById('send-btn').onclick = () => this.sendMessage();
    document.getElementById('user-input').onkeydown = (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        this.sendMessage();
      }
    };
  }
  
  connectWebSocket() {
    this.ws = new WebSocket('ws://localhost:5000/ws');
    
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      
      if (data.type === 'text') {
        this.appendAssistantMessage(data.content);
      } else if (data.type === 'tool_call') {
        this.showToolCall(data.tool_name, data.status, data.result);
      }
    };
  }
  
  async sendMessage() {
    const input = document.getElementById('user-input');
    const message = input.value.trim();
    if (!message) return;
    
    // æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯
    this.appendUserMessage(message);
    input.value = '';
    
    // å‘é€åˆ°åç«¯
    const response = await fetch('/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        conversation_id: this.conversationId,
        message: message
      })
    });
    
    // å¤„ç†æµå¼å“åº”
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      const chunk = decoder.decode(value);
      this.appendAssistantMessage(chunk, true); // è¿½åŠ æ¨¡å¼
    }
  }
  
  appendUserMessage(content) {
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message user';
    messageDiv.innerHTML = `
      <div class="content">${this.escapeHtml(content)}</div>
    `;
    document.getElementById('message-container').appendChild(messageDiv);
    this.scrollToBottom();
  }
  
  appendAssistantMessage(content, append = false) {
    let messageDiv;
    if (append) {
      // è¿½åŠ åˆ°æœ€åä¸€æ¡åŠ©æ‰‹æ¶ˆæ¯
      const messages = document.querySelectorAll('.message.assistant');
      messageDiv = messages[messages.length - 1];
      messageDiv.querySelector('.content').innerHTML += content;
    } else {
      messageDiv = document.createElement('div');
      messageDiv.className = 'message assistant';
      messageDiv.innerHTML = `
        <div class="avatar">ğŸ¤–</div>
        <div class="content">${content}</div>
      `;
      document.getElementById('message-container').appendChild(messageDiv);
    }
    this.scrollToBottom();
  }
  
  showToolCall(toolName, status, result) {
    const toolDiv = document.createElement('div');
    toolDiv.className = 'tool-call';
    toolDiv.innerHTML = `
      <div class="tool-call-header">
        <span class="tool-call-name">âš™ï¸ ${toolName}</span>
        <span class="tool-call-status ${status}">${status}</span>
      </div>
      ${result ? `<div class="tool-call-result">${JSON.stringify(result, null, 2)}</div>` : ''}
    `;
    document.getElementById('message-container').appendChild(toolDiv);
    this.scrollToBottom();
  }
  
  scrollToBottom() {
    const container = document.getElementById('message-container');
    container.scrollTop = container.scrollHeight;
  }
  
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

// åˆå§‹åŒ–
const chat = new ChatInterface();
</script>
```

### 2.2 åç«¯è®¾è®¡ï¼ˆFlaskå¢å¼ºç‰ˆï¼‰

åŸºäºHydroSISçš„ChatServiceè®¾è®¡ï¼Œæ”¹é€ æˆ‘ä»¬çš„`app_local.py`ï¼š

```python
# app_hydronet.py - HydroNetå•†ä¸šç‰ˆä¸»ç¨‹åº

from flask import Flask, request, jsonify, Response, stream_with_context
from flask_cors import CORS
from flask_socketio import SocketIO, emit
import json
import asyncio
from typing import AsyncGenerator
import dashscope  # é˜¿é‡Œäº‘é€šä¹‰åƒé—®SDK
from dashscope import Generation

app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

# ============================================
# 1. é€šä¹‰åƒé—®å®¢æˆ·ç«¯ï¼ˆå‚è€ƒHydroSIS ChatServiceï¼‰
# ============================================

class QwenChatService:
    """é€šä¹‰åƒé—®å¯¹è¯æœåŠ¡ï¼ˆæ”¯æŒå·¥å…·è°ƒç”¨ï¼‰"""
    
    def __init__(self, api_key: str, mcp_manager):
        dashscope.api_key = api_key
        self.mcp_manager = mcp_manager
        self.system_prompt = self._build_system_prompt()
    
    def _build_system_prompt(self) -> str:
        """æ„å»ºç³»ç»Ÿæç¤ºè¯"""
        return """ä½ æ˜¯HydroNetæ°´ç½‘æ™ºèƒ½åŠ©æ‰‹ï¼Œä¸“é—¨å¸®åŠ©ç”¨æˆ·è¿›è¡Œæ°´ç½‘ä»¿çœŸã€è¾¨è¯†ã€è°ƒåº¦ã€æ§åˆ¶å’Œæµ‹è¯•ã€‚

ä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹MCPå·¥å…·ï¼š
- simulation: æ°´ç½‘ä»¿çœŸæ¨¡æ‹Ÿ
- identification: ç³»ç»Ÿè¾¨è¯†
- scheduling: ä¼˜åŒ–è°ƒåº¦
- control: æ§åˆ¶ç­–ç•¥è®¾è®¡
- testing: ç³»ç»Ÿæµ‹è¯•

è¯·ç”¨ç®€æ´ã€ä¸“ä¸šçš„ä¸­æ–‡å›ç­”ã€‚å½“éœ€è¦è®¡ç®—æ—¶ï¼Œä¸»åŠ¨è°ƒç”¨å·¥å…·ã€‚å¯¹äºå…è´¹ç”¨æˆ·ï¼Œæé†’ä»–ä»¬æ¯æœˆåªæœ‰100æ¬¡è°ƒç”¨é¢åº¦ã€‚
"""
    
    async def chat_stream(
        self,
        user_id: str,
        conversation_id: str,
        message: str,
        history: list
    ) -> AsyncGenerator[dict, None]:
        """æµå¼å¯¹è¯ï¼ˆæ”¯æŒå·¥å…·è°ƒç”¨ï¼‰"""
        
        # 1. è·å–MCPå·¥å…·åˆ—è¡¨
        mcp_tools = self.mcp_manager.get_tools_list()
        tools = self._convert_to_qwen_tools(mcp_tools)
        
        # 2. æ„å»ºæ¶ˆæ¯
        messages = [
            {"role": "system", "content": self.system_prompt}
        ] + history + [
            {"role": "user", "content": message}
        ]
        
        # 3. è°ƒç”¨é€šä¹‰åƒé—®ï¼ˆæµå¼ + å·¥å…·è°ƒç”¨ï¼‰
        responses = Generation.call(
            model='qwen-plus',  # æˆ– qwen-maxï¼ˆæ›´å¼ºä½†æ›´è´µï¼‰
            messages=messages,
            tools=tools,
            result_format='message',
            stream=True,
            incremental_output=True
        )
        
        # 4. å¤„ç†å“åº”
        tool_calls = []
        
        for response in responses:
            if response.status_code == 200:
                output = response.output
                
                # å¤„ç†å·¥å…·è°ƒç”¨
                if output.get('choices') and output['choices'][0].get('message'):
                    msg = output['choices'][0]['message']
                    
                    # æœ‰å·¥å…·è°ƒç”¨
                    if msg.get('tool_calls'):
                        for tool_call in msg['tool_calls']:
                            tool_name = tool_call['function']['name']
                            tool_args = json.loads(tool_call['function']['arguments'])
                            
                            # é€šçŸ¥å‰ç«¯å·¥å…·è°ƒç”¨å¼€å§‹
                            yield {
                                'type': 'tool_call',
                                'tool_name': tool_name,
                                'status': 'running',
                                'arguments': tool_args
                            }
                            
                            # æ‰§è¡ŒMCPå·¥å…·
                            try:
                                result = await self.mcp_manager.call_tool(
                                    tool_name,
                                    tool_args,
                                    user_id=user_id
                                )
                                
                                # é€šçŸ¥å‰ç«¯å·¥å…·è°ƒç”¨å®Œæˆ
                                yield {
                                    'type': 'tool_call',
                                    'tool_name': tool_name,
                                    'status': 'completed',
                                    'result': result
                                }
                                
                                tool_calls.append({
                                    'tool_call_id': tool_call['id'],
                                    'role': 'tool',
                                    'name': tool_name,
                                    'content': json.dumps(result)
                                })
                                
                            except Exception as e:
                                yield {
                                    'type': 'tool_call',
                                    'tool_name': tool_name,
                                    'status': 'failed',
                                    'error': str(e)
                                }
                    
                    # æ–‡æœ¬å†…å®¹
                    if msg.get('content'):
                        yield {
                            'type': 'text',
                            'content': msg['content']
                        }
        
        # 5. å¦‚æœæœ‰å·¥å…·è°ƒç”¨ï¼Œéœ€è¦å†æ¬¡è°ƒç”¨LLMç”Ÿæˆæœ€ç»ˆå›ç­”
        if tool_calls:
            messages_with_tools = messages + [
                {"role": "assistant", "content": "", "tool_calls": tool_calls}
            ] + tool_calls
            
            final_responses = Generation.call(
                model='qwen-plus',
                messages=messages_with_tools,
                result_format='message',
                stream=True
            )
            
            for response in final_responses:
                if response.status_code == 200:
                    content = response.output.choices[0].message.content
                    if content:
                        yield {
                            'type': 'text',
                            'content': content
                        }
    
    def _convert_to_qwen_tools(self, mcp_tools: list) -> list:
        """å°†MCPå·¥å…·è½¬æ¢ä¸ºé€šä¹‰åƒé—®æ ¼å¼"""
        return [
            {
                "type": "function",
                "function": {
                    "name": tool['name'],
                    "description": tool['description'],
                    "parameters": tool.get('parameters', {})
                }
            }
            for tool in mcp_tools
        ]


# ============================================
# 2. ç”¨æˆ·ç®¡ç†ï¼ˆæ”¯æŒå…è´¹/ä»˜è´¹åˆ†çº§ï¼‰
# ============================================

class UserManager:
    """ç”¨æˆ·ç®¡ç†ï¼ˆå«å…è´¹ç‰ˆé™åˆ¶ï¼‰"""
    
    def __init__(self, db):
        self.db = db
    
    async def get_user(self, user_id: str) -> dict:
        """è·å–ç”¨æˆ·ä¿¡æ¯"""
        user = await self.db.execute(
            "SELECT * FROM users WHERE id = $1", user_id
        )
        return user
    
    async def check_quota(self, user_id: str) -> dict:
        """æ£€æŸ¥ç”¨æˆ·é…é¢"""
        user = await self.get_user(user_id)
        
        # è·å–æœ¬æœˆä½¿ç”¨é‡
        usage = await self.db.execute("""
            SELECT COUNT(*) as count
            FROM api_calls
            WHERE user_id = $1
              AND created_at >= date_trunc('month', CURRENT_DATE)
        """, user_id)
        
        tier = user['tier']  # 'free', 'pro', 'enterprise'
        limits = {
            'free': 100,
            'pro': 10000,
            'enterprise': -1  # æ— é™
        }
        
        limit = limits.get(tier, 100)
        used = usage['count']
        
        return {
            'tier': tier,
            'limit': limit,
            'used': used,
            'remaining': limit - used if limit != -1 else -1,
            'can_use': used < limit or limit == -1
        }
    
    async def record_api_call(self, user_id: str, endpoint: str):
        """è®°å½•APIè°ƒç”¨"""
        await self.db.execute("""
            INSERT INTO api_calls (user_id, endpoint, created_at)
            VALUES ($1, $2, NOW())
        """, user_id, endpoint)


# ============================================
# 3. Flaskè·¯ç”±ï¼ˆå‚è€ƒHydroSIS APIè®¾è®¡ï¼‰
# ============================================

qwen_service = QwenChatService(
    api_key=os.environ.get('ALIYUN_API_KEY'),
    mcp_manager=mcp_manager
)

user_manager = UserManager(db)

@app.route('/api/chat', methods=['POST'])
async def chat():
    """å¯¹è¯APIï¼ˆæµå¼å“åº”ï¼‰"""
    data = request.json
    user_id = data.get('user_id')
    conversation_id = data.get('conversation_id')
    message = data.get('message')
    
    # 1. æ£€æŸ¥é…é¢
    quota = await user_manager.check_quota(user_id)
    if not quota['can_use']:
        return jsonify({
            'error': 'quota_exceeded',
            'message': f'æ‚¨å·²ç”¨å®Œæœ¬æœˆ{quota["limit"]}æ¬¡å…è´¹é¢åº¦',
            'upgrade_url': '/pricing'
        }), 429
    
    # 2. åŠ è½½å¯¹è¯å†å²
    history = await load_conversation_history(conversation_id)
    
    # 3. æµå¼å“åº”
    async def generate():
        async for chunk in qwen_service.chat_stream(
            user_id, conversation_id, message, history
        ):
            yield f"data: {json.dumps(chunk)}\n\n"
    
    # 4. è®°å½•APIè°ƒç”¨
    await user_manager.record_api_call(user_id, '/api/chat')
    
    return Response(
        stream_with_context(generate()),
        mimetype='text/event-stream'
    )


@app.route('/api/user/quota', methods=['GET'])
async def get_quota():
    """è·å–ç”¨æˆ·é…é¢"""
    user_id = request.args.get('user_id')
    quota = await user_manager.check_quota(user_id)
    return jsonify(quota)


@app.route('/api/user/upgrade', methods=['POST'])
async def upgrade():
    """ç”¨æˆ·å‡çº§ï¼ˆä»˜è´¹ï¼‰"""
    data = request.json
    user_id = data['user_id']
    tier = data['tier']  # 'pro' or 'enterprise'
    
    # TODO: é›†æˆæ”¯ä»˜å®/å¾®ä¿¡æ”¯ä»˜
    # 1. ç”Ÿæˆè®¢å•
    # 2. è°ƒç”¨æ”¯ä»˜æ¥å£
    # 3. æ”¯ä»˜æˆåŠŸåæ›´æ–°ç”¨æˆ·ç­‰çº§
    
    return jsonify({'status': 'pending', 'payment_url': '...'})


# ============================================
# 4. WebSocketæ”¯æŒï¼ˆå®æ—¶é€šä¿¡ï¼‰
# ============================================

@socketio.on('connect')
def handle_connect():
    print('Client connected')

@socketio.on('chat_message')
async def handle_chat_message(data):
    """WebSocketæ¶ˆæ¯å¤„ç†"""
    user_id = data['user_id']
    message = data['message']
    conversation_id = data['conversation_id']
    
    # æ£€æŸ¥é…é¢
    quota = await user_manager.check_quota(user_id)
    if not quota['can_use']:
        emit('error', {
            'type': 'quota_exceeded',
            'message': 'é…é¢å·²ç”¨å®Œ'
        })
        return
    
    # æµå¼å“åº”
    history = await load_conversation_history(conversation_id)
    
    async for chunk in qwen_service.chat_stream(
        user_id, conversation_id, message, history
    ):
        emit('chat_chunk', chunk)
    
    emit('chat_complete', {})


if __name__ == '__main__':
    socketio.run(app, host='0.0.0.0', port=5000, debug=True)
```

### 2.3 MCPæœåŠ¡ç®¡ç†å™¨ï¼ˆé›†æˆæ°´ç½‘ä¸“ä¸šåŠŸèƒ½ï¼‰

```python
# mcp_manager_enhanced.py - å¢å¼ºç‰ˆMCPç®¡ç†å™¨

class MCPServiceManager:
    """MCPæœåŠ¡ç®¡ç†å™¨ï¼ˆæ°´ç½‘ä¸“ä¸šåŠŸèƒ½ï¼‰"""
    
    def __init__(self):
        self.services = {
            'simulation': {
                'name': 'simulation',
                'description': 'æ°´ç½‘ä»¿çœŸæ¨¡æ‹Ÿ',
                'url': 'http://localhost:8001',
                'parameters': {
                    'type': 'object',
                    'properties': {
                        'network_config': {
                            'type': 'object',
                            'description': 'æ°´ç½‘é…ç½®ï¼ˆèŠ‚ç‚¹ã€ç®¡é“ï¼‰'
                        },
                        'boundary_conditions': {
                            'type': 'object',
                            'description': 'è¾¹ç•Œæ¡ä»¶ï¼ˆæµé‡ã€æ°´ä½ï¼‰'
                        },
                        'simulation_duration': {
                            'type': 'number',
                            'description': 'æ¨¡æ‹Ÿæ—¶é•¿ï¼ˆç§’ï¼‰'
                        }
                    },
                    'required': ['network_config', 'boundary_conditions']
                }
            },
            'identification': {
                'name': 'identification',
                'description': 'ç³»ç»Ÿè¾¨è¯†ï¼ˆå‚æ•°ä¼°è®¡ï¼‰',
                'url': 'http://localhost:8002',
                'parameters': {
                    'type': 'object',
                    'properties': {
                        'observed_data': {
                            'type': 'array',
                            'description': 'è§‚æµ‹æ•°æ®'
                        },
                        'model_structure': {
                            'type': 'string',
                            'description': 'æ¨¡å‹ç»“æ„'
                        }
                    },
                    'required': ['observed_data']
                }
            },
            'scheduling': {
                'name': 'scheduling',
                'description': 'ä¼˜åŒ–è°ƒåº¦',
                'url': 'http://localhost:8003',
                'parameters': {
                    'type': 'object',
                    'properties': {
                        'objective': {
                            'type': 'string',
                            'enum': ['minimize_cost', 'maximize_efficiency'],
                            'description': 'ä¼˜åŒ–ç›®æ ‡'
                        },
                        'constraints': {
                            'type': 'object',
                            'description': 'çº¦æŸæ¡ä»¶'
                        }
                    },
                    'required': ['objective']
                }
            },
            'control': {
                'name': 'control',
                'description': 'æ§åˆ¶ç­–ç•¥è®¾è®¡',
                'url': 'http://localhost:8004',
                'parameters': {
                    'type': 'object',
                    'properties': {
                        'control_type': {
                            'type': 'string',
                            'enum': ['PID', 'MPC', 'optimal'],
                            'description': 'æ§åˆ¶ç±»å‹'
                        },
                        'setpoint': {
                            'type': 'number',
                            'description': 'è®¾å®šå€¼'
                        }
                    },
                    'required': ['control_type']
                }
            },
            'testing': {
                'name': 'testing',
                'description': 'ç³»ç»Ÿæµ‹è¯•',
                'url': 'http://localhost:8005',
                'parameters': {
                    'type': 'object',
                    'properties': {
                        'test_scenario': {
                            'type': 'string',
                            'description': 'æµ‹è¯•åœºæ™¯'
                        }
                    },
                    'required': ['test_scenario']
                }
            }
        }
    
    def get_tools_list(self) -> list:
        """è·å–å·¥å…·åˆ—è¡¨ï¼ˆä¾›LLMä½¿ç”¨ï¼‰"""
        return [
            {
                'name': svc['name'],
                'description': svc['description'],
                'parameters': svc['parameters']
            }
            for svc in self.services.values()
        ]
    
    async def call_tool(
        self,
        tool_name: str,
        arguments: dict,
        user_id: str = None
    ) -> dict:
        """è°ƒç”¨MCPå·¥å…·"""
        
        if tool_name not in self.services:
            raise ValueError(f'Unknown tool: {tool_name}')
        
        service = self.services[tool_name]
        
        # å¦‚æœæœ‰URLï¼Œè°ƒç”¨è¿œç¨‹æœåŠ¡
        if service.get('url'):
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{service['url']}/execute",
                    json={'parameters': arguments, 'user_id': user_id}
                ) as response:
                    return await response.json()
        else:
            # æœ¬åœ°Mockå®ç°
            return self._mock_tool_execution(tool_name, arguments)
    
    def _mock_tool_execution(self, tool_name: str, args: dict) -> dict:
        """Mockå·¥å…·æ‰§è¡Œï¼ˆç”¨äºæ¼”ç¤ºï¼‰"""
        
        if tool_name == 'simulation':
            return {
                'status': 'completed',
                'results': {
                    'max_flow': 125.3,
                    'max_pressure': 45.2,
                    'energy_consumption': 1234.5,
                    'plot_url': '/results/simulation_plot.png'
                },
                'message': 'ä»¿çœŸå®Œæˆï¼æœ€å¤§æµé‡125.3 mÂ³/h'
            }
        
        elif tool_name == 'identification':
            return {
                'status': 'completed',
                'parameters': {
                    'roughness': 0.012,
                    'leakage_rate': 0.03,
                    'confidence': 0.95
                },
                'message': 'è¾¨è¯†å®Œæˆï¼ç®¡é“ç²—ç³™åº¦0.012'
            }
        
        # ... å…¶ä»–å·¥å…·çš„mockå®ç°
        
        return {'status': 'completed', 'message': f'{tool_name} æ‰§è¡Œå®Œæˆ'}
```

---

## 3. ä¸¤é˜¶æ®µæŠ€æœ¯æ¼”è¿›

### 3.1 é˜¶æ®µä¸€ï¼šå­¦æ ¡æœåŠ¡å™¨ï¼ˆ0-12æœˆï¼‰

**ç›®æ ‡**ï¼š500-1000ä¸ªç”¨æˆ·

**æŠ€æœ¯æ ˆ**ï¼š
```
å‰ç«¯: HTML/JS/Bootstrap â†’ Vue 3
åç«¯: Flask + PostgreSQL
AI: é€šä¹‰åƒé—®API
MCP: æœ¬åœ°MockæœåŠ¡
å­˜å‚¨: æœåŠ¡å™¨æœ¬åœ°ç£ç›˜
```

**éƒ¨ç½²æ¶æ„**ï¼š
```
å­¦æ ¡100ä¸‡æœåŠ¡å™¨
â”œâ”€â”€ Nginx (åå‘ä»£ç† + é™æ€æ–‡ä»¶)
â”œâ”€â”€ Gunicorn (Flaskåº”ç”¨ Ã— 4å®ä¾‹)
â”œâ”€â”€ PostgreSQL (ç”¨æˆ·æ•°æ® + å¯¹è¯å†å²)
â”œâ”€â”€ Redis (ä¼šè¯ç¼“å­˜ + é™æµ)
â””â”€â”€ é€šä¹‰åƒé—®API (é˜¿é‡Œäº‘)
```

**æˆæœ¬**ï¼š
- æœåŠ¡å™¨ï¼š0å…ƒï¼ˆå­¦æ ¡æä¾›ï¼‰
- é€šä¹‰åƒé—®ï¼š0-500å…ƒ/æœˆï¼ˆå…è´¹é¢åº¦+å°‘é‡ä»˜è´¹ï¼‰
- è¿ç»´äººå‘˜ï¼š8000å…ƒ/æœˆ
- **æ€»è®¡**ï¼šâ‰ˆ10ä¸‡å…ƒ/å¹´

### 3.2 é˜¶æ®µäºŒï¼šæ··åˆäº‘éƒ¨ç½²ï¼ˆ12-24æœˆï¼‰

**ç›®æ ‡**ï¼š2000-3000ä¸ªç”¨æˆ·

**æŠ€æœ¯æ ˆæ¼”è¿›**ï¼š
```
å‰ç«¯: Vue 3 + CDNåŠ é€Ÿ
åç«¯: Flask â†’ FastAPI (å¼‚æ­¥)
æ•°æ®åº“: PostgreSQLä¸»ä»å¤åˆ¶
ç¼“å­˜: Redisé›†ç¾¤
æ¶ˆæ¯é˜Ÿåˆ—: RabbitMQ
MCP: Dockerå®¹å™¨åŒ–
```

**æ¶æ„è°ƒæ•´**ï¼š
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¿é‡Œäº‘ï¼ˆæ–°å®¢æˆ·ï¼‰        â”‚     â”‚ å­¦æ ¡æœåŠ¡å™¨ï¼ˆè€å®¢æˆ·ï¼‰      â”‚
â”‚  - ECS Ã— 2              â”‚     â”‚  - ç»§ç»­æœåŠ¡              â”‚
â”‚  - RDS PostgreSQL       â”‚     â”‚  - é€æ­¥è¿ç§»              â”‚
â”‚  - Redis                â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  - OSS                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
  é€šä¹‰åƒé—®APIï¼ˆå…±ç”¨ï¼‰
```

---

## 4. ç”¨æˆ·å¢é•¿æŠ€æœ¯æ”¯æ’‘

### 4.1 å…è´¹å¢å€¼åŠŸèƒ½å®ç°

```python
# åŠŸèƒ½åˆ†çº§è¡¨
TIER_FEATURES = {
    'free': {
        'api_calls_per_month': 100,
        'max_conversations': 10,
        'max_file_size_mb': 10,
        'mcp_services': ['simulation'],  # ä»…ä»¿çœŸ
        'support': 'community',
        'branding': True,  # æ˜¾ç¤º"ç”±HydroNetæä¾›"
    },
    'pro': {
        'api_calls_per_month': 10000,
        'max_conversations': 100,
        'max_file_size_mb': 100,
        'mcp_services': ['simulation', 'identification', 'scheduling'],
        'support': 'email',
        'branding': False,
        'priority': True,
    },
    'enterprise': {
        'api_calls_per_month': -1,  # æ— é™
        'max_conversations': -1,
        'max_file_size_mb': 500,
        'mcp_services': 'all',
        'support': '24x7',
        'branding': False,
        'priority': True,
        'custom_deployment': True,
    }
}

# åŠŸèƒ½æ£€æŸ¥è£…é¥°å™¨
def require_feature(feature_name: str, tier_required: str = 'pro'):
    def decorator(func):
        async def wrapper(*args, **kwargs):
            user_id = kwargs.get('user_id')
            user = await get_user(user_id)
            
            tier_level = {'free': 1, 'pro': 2, 'enterprise': 3}
            if tier_level[user.tier] < tier_level[tier_required]:
                return {
                    'error': 'feature_locked',
                    'message': f'æ­¤åŠŸèƒ½éœ€è¦{tier_required}ç‰ˆæœ¬',
                    'upgrade_url': '/pricing'
                }
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@app.route('/api/mcp/scheduling', methods=['POST'])
@require_feature('scheduling', 'pro')
async def run_scheduling(user_id: str, params: dict):
    # ... æ‰§è¡Œè°ƒåº¦ ...
    pass
```

### 4.2 æ¨èç³»ç»Ÿå®ç°

```python
# referral_system.py - æ¨èè£‚å˜ç³»ç»Ÿ

class ReferralSystem:
    """æ¨èç³»ç»Ÿ"""
    
    def __init__(self, db):
        self.db = db
    
    async def generate_referral_code(self, user_id: str) -> str:
        """ç”Ÿæˆæ¨èç """
        code = hashlib.md5(f"{user_id}{time.time()}".encode()).hexdigest()[:8]
        
        await self.db.execute("""
            INSERT INTO referral_codes (user_id, code, created_at)
            VALUES ($1, $2, NOW())
        """, user_id, code)
        
        return code
    
    async def register_with_referral(
        self,
        username: str,
        email: str,
        password: str,
        referral_code: str = None
    ) -> dict:
        """é€šè¿‡æ¨èç æ³¨å†Œ"""
        
        # 1. åˆ›å»ºç”¨æˆ·
        user_id = await self.create_user(username, email, password)
        
        # 2. å¦‚æœæœ‰æ¨èç ï¼Œå¤„ç†å¥–åŠ±
        if referral_code:
            referrer = await self.db.execute("""
                SELECT user_id FROM referral_codes WHERE code = $1
            """, referral_code)
            
            if referrer:
                # è®°å½•æ¨èå…³ç³»
                await self.db.execute("""
                    INSERT INTO referrals (referrer_id, referee_id, created_at)
                    VALUES ($1, $2, NOW())
                """, referrer['user_id'], user_id)
                
                # å¥–åŠ±æ¨èäººï¼ˆå»¶é•¿è¯•ç”¨æœŸï¼‰
                await self.reward_referrer(referrer['user_id'], 'trial_extension', 30)
                
                # å¥–åŠ±è¢«æ¨èäººï¼ˆå»¶é•¿è¯•ç”¨æœŸï¼‰
                await self.reward_referee(user_id, 'trial_extension', 30)
        
        return {'user_id': user_id, 'referral_applied': bool(referral_code)}
    
    async def reward_referrer(self, user_id: str, reward_type: str, value: int):
        """å¥–åŠ±æ¨èäºº"""
        if reward_type == 'trial_extension':
            # å»¶é•¿è¯•ç”¨æœŸ
            await self.db.execute("""
                UPDATE users
                SET trial_end_date = trial_end_date + INTERVAL '$1 days'
                WHERE id = $2
            """, value, user_id)
        
        elif reward_type == 'cash':
            # ç°é‡‘å¥–åŠ±
            await self.db.execute("""
                INSERT INTO rewards (user_id, type, amount, status)
                VALUES ($1, 'cash', $2, 'pending')
            """, user_id, value)
    
    async def get_referral_stats(self, user_id: str) -> dict:
        """è·å–æ¨èç»Ÿè®¡"""
        stats = await self.db.execute("""
            SELECT 
                COUNT(*) as total_referrals,
                COUNT(CASE WHEN r.status = 'converted' THEN 1 END) as paid_referrals,
                SUM(rw.amount) as total_rewards
            FROM referrals r
            LEFT JOIN rewards rw ON rw.user_id = r.referrer_id
            WHERE r.referrer_id = $1
        """, user_id)
        
        return stats
```

### 4.3 æ•°æ®åˆ†æå’Œå¢é•¿ç›‘æ§

```python
# analytics.py - å¢é•¿æ•°æ®åˆ†æ

class GrowthAnalytics:
    """å¢é•¿æ•°æ®åˆ†æ"""
    
    def __init__(self, db):
        self.db = db
    
    async def get_growth_metrics(self, date_range: tuple) -> dict:
        """è·å–å¢é•¿æŒ‡æ ‡"""
        
        # 1. æ–°ç”¨æˆ·æ³¨å†Œ
        new_users = await self.db.execute("""
            SELECT DATE(created_at) as date, COUNT(*) as count
            FROM users
            WHERE created_at BETWEEN $1 AND $2
            GROUP BY DATE(created_at)
            ORDER BY date
        """, date_range[0], date_range[1])
        
        # 2. æ´»è·ƒç”¨æˆ·(MAU)
        mau = await self.db.execute("""
            SELECT COUNT(DISTINCT user_id) as mau
            FROM api_calls
            WHERE created_at >= NOW() - INTERVAL '30 days'
        """)
        
        # 3. ä»˜è´¹è½¬åŒ–ç‡
        conversion = await self.db.execute("""
            SELECT 
                COUNT(CASE WHEN tier = 'free' THEN 1 END) as free_users,
                COUNT(CASE WHEN tier != 'free' THEN 1 END) as paid_users,
                COUNT(CASE WHEN tier != 'free' THEN 1 END)::float / COUNT(*)::float as conversion_rate
            FROM users
            WHERE created_at <= $1
        """, date_range[1])
        
        # 4. ç•™å­˜ç‡
        retention = await self.db.execute("""
            WITH cohort AS (
                SELECT 
                    DATE_TRUNC('month', created_at) as cohort_month,
                    user_id
                FROM users
            ),
            activity AS (
                SELECT 
                    c.cohort_month,
                    c.user_id,
                    DATE_TRUNC('month', a.created_at) as activity_month,
                    EXTRACT(MONTH FROM AGE(a.created_at, c.cohort_month)) as month_number
                FROM cohort c
                LEFT JOIN api_calls a ON c.user_id = a.user_id
            )
            SELECT 
                cohort_month,
                month_number,
                COUNT(DISTINCT user_id) as active_users
            FROM activity
            GROUP BY cohort_month, month_number
            ORDER BY cohort_month, month_number
        """)
        
        # 5. æ¨èæ•ˆæœ
        referral_effect = await self.db.execute("""
            SELECT 
                COUNT(*) as total_referrals,
                COUNT(CASE WHEN ref.status = 'converted' THEN 1 END) as converted,
                AVG(EXTRACT(DAY FROM ref.converted_at - ref.created_at)) as avg_conversion_days
            FROM referrals ref
            WHERE ref.created_at BETWEEN $1 AND $2
        """, date_range[0], date_range[1])
        
        return {
            'new_users': new_users,
            'mau': mau['mau'],
            'conversion_rate': conversion['conversion_rate'],
            'retention_cohort': retention,
            'referral_effect': referral_effect
        }
    
    async def generate_growth_report(self) -> dict:
        """ç”Ÿæˆå¢é•¿æŠ¥å‘Š"""
        # ... ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š ...
        pass
```

---

## 5. å¿«é€Ÿå®æ–½è·¯çº¿

### 5.1 ç¬¬ä¸€ä¸ªæœˆï¼ˆMVPï¼‰

**Week 1-2: å‰ç«¯æ”¹é€ **
```bash
â–¡ åŸºäºç°æœ‰index.htmlæ”¹é€ æˆClaudeé£æ ¼
â–¡ æ·»åŠ å¯¹è¯å†å²ä¾§è¾¹æ 
â–¡ å®ç°æµå¼æ¶ˆæ¯å±•ç¤º
â–¡ æ·»åŠ å·¥å…·è°ƒç”¨å¯è§†åŒ–
â–¡ é…é¢æ˜¾ç¤ºå’Œå‡çº§æç¤º
```

**Week 3: åç«¯é›†æˆ**
```bash
â–¡ é›†æˆé€šä¹‰åƒé—®API
â–¡ å®ç°æµå¼å“åº”
â–¡ æ·»åŠ å·¥å…·è°ƒç”¨åŠŸèƒ½
â–¡ MCPæœåŠ¡Mockå®ç°
â–¡ WebSocketæ”¯æŒ
```

**Week 4: ç”¨æˆ·ç³»ç»Ÿ**
```bash
â–¡ ç”¨æˆ·æ³¨å†Œ/ç™»å½•
â–¡ å…è´¹ç‰ˆé…é¢é™åˆ¶
â–¡ æ¨èç ç”Ÿæˆ
â–¡ æ•°æ®åº“è®¾è®¡å’Œè¿ç§»
â–¡ éƒ¨ç½²åˆ°å­¦æ ¡æœåŠ¡å™¨
```

### 5.2 ç¬¬2-3ä¸ªæœˆï¼ˆå¢é•¿åŠŸèƒ½ï¼‰

```bash
â–¡ å®Œå–„æ¨èè£‚å˜ç³»ç»Ÿ
â–¡ é›†æˆæ”¯ä»˜æ¥å£ï¼ˆæ”¯ä»˜å®/å¾®ä¿¡ï¼‰
â–¡ æ·»åŠ æ•°æ®åˆ†æä»ªè¡¨ç›˜
â–¡ å®ç°çœŸå®MCPæœåŠ¡ï¼ˆDockeråŒ–ï¼‰
â–¡ æ€§èƒ½ä¼˜åŒ–å’Œå‹åŠ›æµ‹è¯•
â–¡ å¢é•¿å®éªŒï¼ˆABæµ‹è¯•ï¼‰
```

### 5.3 ç¬¬4-6ä¸ªæœˆï¼ˆè§„æ¨¡åŒ–å‡†å¤‡ï¼‰

```bash
â–¡ å‡çº§åˆ°Vue 3å‰ç«¯
â–¡ FastAPIå¼‚æ­¥åç«¯
â–¡ Redisé›†ç¾¤
â–¡ PostgreSQLä¸»ä»å¤åˆ¶
â–¡ CDNåŠ é€Ÿ
â–¡ ç›‘æ§å‘Šè­¦ç³»ç»Ÿ
â–¡ å‡†å¤‡é˜¿é‡Œäº‘è¿ç§»æ–¹æ¡ˆ
```

---

## ğŸ“Š é¢„æœŸæ•ˆæœ

### æŠ€æœ¯æŒ‡æ ‡

```
æ€§èƒ½ç›®æ ‡:
  - å“åº”æ—¶é—´: <200ms (ä¸å«AIæ¨ç†)
  - å¹¶å‘ç”¨æˆ·: 500+ (é˜¶æ®µä¸€)
  - å¯ç”¨æ€§: 99.5%
  - AIå“åº”: <3s (æµå¼é¦–å­—èŠ‚)

å¢é•¿æŒ‡æ ‡:
  - ç¬¬1ä¸ªæœˆ: 50-100ä¸ªç”¨æˆ·
  - ç¬¬3ä¸ªæœˆ: 300-500ä¸ªç”¨æˆ·
  - ç¬¬6ä¸ªæœˆ: 800-1000ä¸ªç”¨æˆ·
  - å…è´¹è½¬ä»˜è´¹: >15%
  - æ¨èKå› å­: >1.5
```

### æˆæœ¬ä¼˜åŠ¿

```
å¯¹æ¯”ä¼ ç»ŸSaaS:
  ä¼ ç»Ÿ: éœ€è¦30-50ä¸‡/å¹´äº‘æœåŠ¡å™¨æˆæœ¬
  æˆ‘ä»¬: ä»…éœ€10ä¸‡/å¹´ï¼ˆå­¦æ ¡æ”¯æŒï¼‰
  
èŠ‚çœ: 40ä¸‡/å¹´
èŠ‚çœç‡: 80%

è¿™å°±æ˜¯æˆ‘ä»¬çš„æ ¸å¿ƒç«äº‰åŠ›ï¼ğŸš€
```

---

## ğŸ¯ æ€»ç»“

åŸºäºHydroSISäº‘æœåŠ¡æ¶æ„æ–¹æ¡ˆï¼Œæˆ‘ä»¬ä¸ºHydroNetè®¾è®¡äº†ï¼š

1. **MVPå¿«é€Ÿå¯åŠ¨**ï¼š1ä¸ªæœˆå†…ä¸Šçº¿ç±»Claudeå¯¹è¯ç•Œé¢
2. **ç”¨æˆ·å¢é•¿é©±åŠ¨**ï¼šå…è´¹å¢å€¼ + æ¨èè£‚å˜
3. **æˆæœ¬æä½**ï¼šå­¦æ ¡æ”¯æŒ + é€šä¹‰åƒé—®å…è´¹é¢åº¦
4. **æŠ€æœ¯å…ˆè¿›**ï¼šæµå¼å“åº” + å·¥å…·è°ƒç”¨ + MCPåè®®
5. **å¯æ‰©å±•æ€§**ï¼šå¹³æ»‘è¿‡æ¸¡åˆ°é˜¿é‡Œäº‘

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨**ï¼šç«‹å³å¼€å§‹Week 1å¼€å‘ï¼ğŸš€
